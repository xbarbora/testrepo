#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Apr 13 17:48:51 2018

@author: kushal

Chatzigeorgiou Group
Sars International Centre for Marine Molecular Biology

GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
"""

import numpy as np; import numba; import tifffile; import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtGui, QtWidgets
from skimage import transform

fileinput = 'F:/juvenile/10.tiff'
fileoutput = fileinput[:-5] + '_cropped.tiff'

tif = tifffile.TiffFile(fileinput, is_nih=True)
# For concatted tiffs
seq = tif.pages[0].asarray()

# For AwesomeImager tiffs
#seq = tif.series[0].asarray()

class ImageFuncs:
    """Misc image functions"""
    @staticmethod
    def create_LUT_8bit(levels, src_depth):
        """
        :param src_depth:   bit depth of the source
        :type src_depth:    int
        :param levels:      min and max levels with which to create the LUT
        :type levels:       tuple
        :return:            8 bit LUT to convert the source's bit depth to 8 bit
        :rtype:             np.ndarray
        """

        accepted_depths = [16, 32, 64]
        if src_depth not in accepted_depths:
            raise TypeError('Can only convert from uint16, uint32, or uint64')
        depth = 'uint' + str(src_depth)
        LUT = np.arange(2**src_depth, dtype=depth)
        LUT.clip(levels[0], levels[1], out=LUT)
        LUT -= levels[0]
        np.floor_divide(LUT, (levels[1] - levels[0] + 1) / 256, out=LUT, casting='unsafe')

        return LUT.astype(np.uint8)

    @staticmethod
    def apply_8bit_LUT(image, LUT):
        """
        :param image:   The image upon which to apply the LUT and change its bit depth
        :type image:    np.ndarray
        :param LUT:     The 8bit LUT to use for downscaling the bit depth. Generated by ImageFuncs.create_LUT_8bit
        :type LUT:      np.ndarray
        :return:        Downscaled 8 bit image with the LUT applied to it
        :rtype:         np.ndarray
        """
        return np.take(LUT, image).astype(np.uint8)

app = QtWidgets.QApplication([])
iv = pg.imageview.ImageView()
iv.setImage(seq)
hist = iv.getHistogramWidget()
iv.show()
QtWidgets.QApplication.instance().exec_()

#%%
p_right = iv.getImageItem().mapFromScene(iv.roi.getSceneHandlePositions()[0][1])
p_left = iv.getImageItem().mapFromScene(iv.roi.getSceneHandlePositions()[1][1])

pl = (int(p_left.x()), int(p_left.y()))
pr = (int(p_right.x()), int(p_right.y()))

levels = list(hist.getLevels())

levels[1] = int(levels[1])
levels[0] = int(levels[0])

lut = ImageFuncs.create_LUT_8bit(levels, 16)

@numba.jit
def crop_imgseq(a, pl, pr):
    return a[pl[1]:pr[1], pl[0]:pr[0], :]

@numba.jit
def rescale_fast(img, factor, LUT):
    tmpl = transform.rescale(img[:,:,:2], factor)
    s = np.zeros((tmpl.shape[0], tmpl.shape[1], img.shape[2]), dtype=np.uint16)
    for i in range(0, img.shape[2]):
        print(i)
        s[:,:,i] = transform.rescale(img[:,:,i], factor, preserve_range=True)
    r = np.zeros((tmpl.shape[0], tmpl.shape[1], img.shape[2]), dtype=np.uint8)
    for i in range(0, img.shape[2]):
        print('downscaling bit depth')
        print(i)
        r[:,:,i] = np.take(LUT, s[:,:,i]).astype(np.uint8)
        print(r.dtype)
    return r


seq = tif.asarray(maxworkers=4)
cropped = crop_imgseq(seq.T, pl, pr)

del seq

scaled = rescale_fast(cropped, 0.5, lut)
del cropped
iv.setImage(scaled[:,:,0])
iv.show()

tifffile.imsave(fileoutput, scaled.T)

#%%
#
#@numba.jit
#def tiff_to_np(**kwargs):
#    if 'tif_obj' not in kwargs.keys():
#        raise ValueError('Must pass a tif object')
#    else:
#        tif_obj = tifffile.TiffFile(kwargs[])
#        tif_obj = kwargs['tif_obj']
#
#    if 'start' not in kwargs.keys():
#        start = 0
#    else:
#        start = kwargs['start']
#        
#    if 'stop' not in kwargs.keys():
#        stop = stop = len(tif.series)
#    else:
#        stop = kwargs['stop']
#        
#    s = tif_obj.series[0].asarray().shape
#    
#    out = np.zeros((s[0], s[1], stop), dtype=np.uint8)
#    
#    for i in range(start, stop + 1):
#        print(i)
#        out[:,:,i] = tif_obj.series[i].asarray()
#    
#    tif_obj.close()
#    
#    if 'q' in kwargs.keys():
#        kwargs['q'].put([start, stop, out])
#    else:
#        return out
#
#%%
#tif = tifffile.TiffFile('/home/kushal/Sars_stuff/For_Methods_Paper/Eef1/a5_t1.tiff')
#array = tiff_to_np({'tif_obj': tif})
#
#%%
#
#def tiff_loader_multiprocess(filepath, n):
#    tif = tifffile.TiffFile(filepath)
#    
#    num_frames = len(tif.series)
#    intervals = np.arange(0, num_frames, num_frames/n, dtype=int)
#    
#    q = multiprocessing.Queue()
##    qtif = multiprocessing.Queue()
#    p = []
#    tif.close()
#    
#    for i in range(n):
#        if i == 0:
#            start_frame = 0
#        else:
#            start_frame = intervals[i] + 1
#        if i == n - 1:
#            stop_frame = num_frames
#        else:
#            stop_frame = intervals[i + 1]
#            
##        qtif.put(tif)
#        
#        kwargs = {'tif_obj': filepath,
#                  'start': start_frame, 
#                  'stop': stop_frame,
#                  'pipe': q}
#        
#        p.append(multiprocessing.Process(target=tiff_to_np, args=(kwargs,)))
#        p[-1].start()
#        
#    for process in p:
#        process.join()
#        
#    return q

#%%

#Q = tiff_loader_multiprocess('/home/kushal/Sars_stuff/For_Methods_Paper/Eef1/a5_t1.tiff', 3)
